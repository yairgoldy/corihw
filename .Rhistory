library(R.utils)
library(Matrix)
library("corihw")
library("tidyverse")
rho <- sqrt(rhosq)
nblock <- 100
set.seed(seed = 10*seed)
message(paste("seed=",seed))
mat <- Matrix((1-rho)*diag(nblock)+matrix(rho,nblock,nblock))
lmat <- list()
Z <- NULL
for(i in 1:ceiling(m/nblock)){
lmat <-c(lmat,mat)
Z <- rbind(Z,rmvnorm(n = 1, sigma=as.matrix(mat)))
}
Sigma <- bdiag(lmat)
Sigma <- Sigma[1:m,1:m]
Sigma[1:10,1:10]
Sigma[1:10,1:10]
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/bound3test.R')
bound3(Sigma[1:100,100])
bound3(Sigma[1:100,100],m = 100,m_block = 100)
bound3(Sigma[1:100,1:100],m = 100,m_block = 100)
load("(gamma_rho_pairs")
load("C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/OldCode/norm_table.Rdat")
#' bound3: Bound on a uniuon of events
#'
#'
#' Compute a bound that the probability max_j |X_j|>PhiInv(1-alpha/2)
#' where X=(X_1,...,X_m)~MVN(0,Sigma)
#' and PhiInv is the inverse of the standard normal distribution
#'
#'
#'
#' @param Sigma   A sparse mxm corrolation matrix
#' @param m       Dimension of the matrix Sigma
#' @param m_block The matrix Sigma is treated as a block diagonal
#'  with m_block by m_block blocks. All elements outside the block are treated as zero.
#'
#' @return A function which for a vector of alpha return the bound
#' @seealso ??
#'
#' @examples
#' library(Matrix)
# m <- 1000
# Sigma <-  Matrix(runif(m^2),m, m,sparse=T)
# m_block <- 100
# f <- bound3(Sigma,m,m_block)
# alpha <- seq(0,0.001,by = 0.00001)
# plot(alpha,f(alpha),type="l")
#'
#' @importFrom Matrix Matrix
#' @import tibble
#' @import dplyr
#' @export
bound3 <- function(Sigma,m=NULL,m_block=100){
load("C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/OldCode/norm_table.Rdat")
if(is.null(m)) m <- nrow(Sigma)
Sigma <- Matrix(Sigma,sparse = T)
if(m_block>=m) m_block <- m
# Calculate number of blocks on the diagonal
nsubmats <-ceiling(m/m_block)
# Create a table of the blocks (blks) and their indices (inds)
subinds <- tibble(blks=1:nsubmats) %>% rowwise() %>%
mutate(inds=list( seq(m_block*(blks-1)+1, min(m_block*blks,m),by = 1)))
rho <- unique(gamma_rho_pairs$rho)
#rho <- rho[which(rho!=0)]
diff <- rho[2]-rho[1]
# bound3 is based on counting the number of 2x2 matrices [1,rho; rho;1] and 3x3 matrices with off-diagonal elements (rho1,rho2,rho3)
# Holds the 2x2 matrix-type counts as a function of rho
rho_pairs <- tibble(rho,summands=0)
# Holds the 3x3 matrix-type counts as a function of rho1,rho2,rho3, order does not matter
rho_triples <- expand.grid(rho,rho,rho) %>% as_tibble() %>%
rename(rho1=Var1,rho2=Var2,rho3=Var3) %>% dplyr::filter(rho1<=rho2, rho2<=rho3) %>% mutate(summands=0)
rholist <- list(rho_pairs=rho_pairs,rho_triples=rho_triples)
# Performs the counts using bound3_matcount
for( blk in subinds$blks){
inds <- subinds$inds[[blk]]
Sigma_local <- Sigma[inds,inds]
rholist <- bound3_matcount(rho_pairs = rholist$rho_pair,
rho_triples = rholist$rho_triples,
Sigma = Sigma_local,m = m_block,diff = diff)
}
# Add the 2x2 matrices with rho=0
rho_pairs <- rholist$rho_pairs
num2by2mast <- choose(m,2)
counted2by2mats <-  dplyr::filter(rho_pairs, rho!= 0) %>% summarise( sums=sum(summands)) %>% select(sums) %>%  unlist(use.names = F)
rho_pairs <- mutate(rho_pairs,
summands= ifelse(rho==0,num2by2mast-counted2by2mats,summands))
# Add the 3x3 matrices with rho1=rho2=rho3=0
rho_triples <- rholist$rho_triples
num3by3mast <- choose(m,3)
counted3by3mats <-  dplyr::filter(rho_triples,  rho1 > 0 | rho2 > 0 | rho3 >0 ) %>% summarise( sums=sum(summands)) %>% select(sums) %>% unlist(use.names = F)
rho_triples <- mutate(rho_triples,
summands= ifelse(rho1 == 0 & rho2 == 0  & rho3 == 0,num3by3mast-counted3by3mats,summands))
# Compute S1, S2 and S3 which are sum_j P(|X_j|>gamma), sum_jk P(|X_j|>gamma,|X_k|>gamma) and
# sum_jkl P(|X_j|>gamma,|X_k|>gamma,|X_l>gamma) where gamma=PhiInv(1-alpha/2)
gamma <- unique(gamma_rho_pairs$gamma)
S1 <- m*2*pnorm(-gamma)
S2 <- inner_join(gamma_rho_pairs,rho_pairs,by="rho") %>%
group_by(gamma) %>% summarise(pr=sum(summands*prob)) %>% select(pr) %>% unlist()
S3 <-  inner_join(gamma_rho_triples,rho_triples,by=c("rho1","rho2","rho3")) %>%
group_by(gamma) %>% summarise(pr=sum(summands*prob))%>% select(pr) %>% unlist()
bounds <- tibble(gamma,S1,S2,S3) %>%
mutate(alpha=gamma2alpha(gamma),
bound1=pmin(1,S1-S2+S3,S1-(2*m-3)*S2/choose(m,2)+(m-2)*S3/choose(m,3) ),
beta1 = S1,
beta2= S1+2*S2,
beta3= S1+6*S2+6*S3,
k=floor((beta3-beta2)/(beta2-beta1)),
cond1= (k>=2 & k<m),
cond2= (k*(k+1)*beta1-(2*k+1)*beta2+beta3>=0),
cond3= (k*(k+1)-(2*k+1+k*(k+1))*beta1+(2*k+2)*beta2-beta3 >=0),
allcond= cond1 & cond2 & cond3,
bound2=pmin(1,1-( k*(k+1)*(1-beta1) + (2*k+1)*(beta2-beta1) -(beta3-beta2) )/(k^2+k) ),
bound=ifelse(allcond,bound2,bound1)  )%>%
#          bound=pmin(1,S1-S2+S3,S1-(2*m-3)*S2/choose(m,2)+(m-2)*S3/choose(m,3) )) %>%
select(alpha,bound)
bounds <- add_row(bounds,alpha=c(0,1),bound=c(0,1))
return(approxfun(bounds$alpha,bounds$bound,method = "linear"))
}
#' @import Matrix
#' @import tibble
#' @import tidyverse
bound3_matcount <- function(rho_pairs,rho_triples,Sigma,m,diff){
if(m<3){
return(list(rho_pairs=rho_pairs,rho_triples=rho_triples))
}
# Prepare Sigma to be in a triplet representation
# Note that rho is calculated with respect to the square of the correlation!!!
Sigma <- Matrix(round(floor(Sigma^2/diff+1e-10)*diff,digits=1)) %>%  triu(k = 1) %>% slam::as.simple_triplet_matrix()
Sigma <- tibble(i=Sigma$i,j=Sigma$j,rho=Sigma$v)
possible_pairs <- expand.grid(1:m,1:m) %>% as_tibble() %>%
rename(i=Var1,j=Var2) %>% dplyr::filter(i<j)
#Sigma <- inner_join(possible_pairs,Sigma,by=c("i","j"))
Sigma <- left_join(possible_pairs,Sigma,by=c("i","j")) %>% mutate(rho=ifelse(is.na(rho),0,rho))
# Sum 2x2 matrices
local_rho_pairs <- group_by(Sigma,rho) %>% summarise(summands=n()) # vector of the number of each rho
rho_pairs <- left_join(rho_pairs,local_rho_pairs,by="rho") %>%
mutate(summands=ifelse(is.na(summands.y),summands.x,summands.x+summands.y)) %>%
select(-summands.x,-summands.y)
# Sum 3x3 matrices. Note that a 3x3 matrix is defined by its 3 indices i,j,k
Sigma_ij <- Sigma %>% rename(rho_ij=rho)
Sigma_ik <- Sigma %>% rename(rho_ik=rho,k=j)
Sigma_jk <- Sigma %>% rename(rho_jk=rho,k=j,j=i)
all_triples <- inner_join(Sigma_ij,Sigma_ik,by="i") %>%  dplyr::filter(j<k) %>%
inner_join(Sigma_jk,by=c("j","k")) %>% select(i,j,k,everything())  # Create all 3x3 submatrices
#order the rhos such that rho1<=rho2<=rho3
sorted_triples <- mutate(all_triples,rho1=pmin(rho_ij,rho_ik,rho_jk),
rho2=ifelse(rho_ij<=rho_ik & rho_ij<= rho_jk,ifelse(rho_ik<=rho_jk, rho_ik,rho_jk),
ifelse(rho_jk<=rho_ik & rho_jk<= rho_ij,ifelse(rho_ij<=rho_ik, rho_ij,rho_ik),
ifelse(rho_ij<=rho_jk, rho_ij,rho_jk))),
rho3=pmax(rho_ij,rho_ik,rho_jk)) %>%  select(rho1,rho2,rho3) %>%
group_by(rho1,rho2,rho3) %>% summarise(summands=n())
# Add to the original table of 3x3 matrices
rho_triples <- left_join(rho_triples,sorted_triples,by=c("rho1","rho2","rho3")) %>%
mutate(summands=ifelse(is.na(summands.y),summands.x,summands.x+summands.y)) %>%
select(-summands.x,-summands.y)
return(list(rho_pairs=rho_pairs,rho_triples=rho_triples))
}
bound3(Sigma[1:100,1:100],m = 100,m_block = 100)
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/bound3test.R')
Sigma
m
bound3(Sigma[1:100,1:100],m = 100,m_block = 100)
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/bound3test.R')
bound3 <- function(Sigma,m=NULL,m_block=100){
load("C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/OldCode/norm_table.Rdat")
source("R/helpers.R")
if(is.null(m)) m <- nrow(Sigma)
Sigma <- Matrix(Sigma,sparse = T)
if(m_block>=m) m_block <- m
# Calculate number of blocks on the diagonal
nsubmats <-ceiling(m/m_block)
# Create a table of the blocks (blks) and their indices (inds)
subinds <- tibble(blks=1:nsubmats) %>% rowwise() %>%
mutate(inds=list( seq(m_block*(blks-1)+1, min(m_block*blks,m),by = 1)))
rho <- unique(gamma_rho_pairs$rho)
#rho <- rho[which(rho!=0)]
diff <- rho[2]-rho[1]
# bound3 is based on counting the number of 2x2 matrices [1,rho; rho;1] and 3x3 matrices with off-diagonal elements (rho1,rho2,rho3)
# Holds the 2x2 matrix-type counts as a function of rho
rho_pairs <- tibble(rho,summands=0)
# Holds the 3x3 matrix-type counts as a function of rho1,rho2,rho3, order does not matter
rho_triples <- expand.grid(rho,rho,rho) %>% as_tibble() %>%
rename(rho1=Var1,rho2=Var2,rho3=Var3) %>% dplyr::filter(rho1<=rho2, rho2<=rho3) %>% mutate(summands=0)
rholist <- list(rho_pairs=rho_pairs,rho_triples=rho_triples)
# Performs the counts using bound3_matcount
for( blk in subinds$blks){
inds <- subinds$inds[[blk]]
Sigma_local <- Sigma[inds,inds]
rholist <- bound3_matcount(rho_pairs = rholist$rho_pair,
rho_triples = rholist$rho_triples,
Sigma = Sigma_local,m = m_block,diff = diff)
}
# Add the 2x2 matrices with rho=0
rho_pairs <- rholist$rho_pairs
num2by2mast <- choose(m,2)
counted2by2mats <-  dplyr::filter(rho_pairs, rho!= 0) %>% summarise( sums=sum(summands)) %>% select(sums) %>%  unlist(use.names = F)
rho_pairs <- mutate(rho_pairs,
summands= ifelse(rho==0,num2by2mast-counted2by2mats,summands))
# Add the 3x3 matrices with rho1=rho2=rho3=0
rho_triples <- rholist$rho_triples
num3by3mast <- choose(m,3)
counted3by3mats <-  dplyr::filter(rho_triples,  rho1 > 0 | rho2 > 0 | rho3 >0 ) %>% summarise( sums=sum(summands)) %>% select(sums) %>% unlist(use.names = F)
rho_triples <- mutate(rho_triples,
summands= ifelse(rho1 == 0 & rho2 == 0  & rho3 == 0,num3by3mast-counted3by3mats,summands))
# Compute S1, S2 and S3 which are sum_j P(|X_j|>gamma), sum_jk P(|X_j|>gamma,|X_k|>gamma) and
# sum_jkl P(|X_j|>gamma,|X_k|>gamma,|X_l>gamma) where gamma=PhiInv(1-alpha/2)
gamma <- unique(gamma_rho_pairs$gamma)
S1 <- m*2*pnorm(-gamma)
S2 <- inner_join(gamma_rho_pairs,rho_pairs,by="rho") %>%
group_by(gamma) %>% summarise(pr=sum(summands*prob)) %>% select(pr) %>% unlist()
S3 <-  inner_join(gamma_rho_triples,rho_triples,by=c("rho1","rho2","rho3")) %>%
group_by(gamma) %>% summarise(pr=sum(summands*prob))%>% select(pr) %>% unlist()
bounds <- tibble(gamma,S1,S2,S3) %>%
mutate(alpha=gamma2alpha(gamma),
bound1=pmin(1,S1-S2+S3,S1-(2*m-3)*S2/choose(m,2)+(m-2)*S3/choose(m,3) ),
beta1 = S1,
beta2= S1+2*S2,
beta3= S1+6*S2+6*S3,
k=floor((beta3-beta2)/(beta2-beta1)),
cond1= (k>=2 & k<m),
cond2= (k*(k+1)*beta1-(2*k+1)*beta2+beta3>=0),
cond3= (k*(k+1)-(2*k+1+k*(k+1))*beta1+(2*k+2)*beta2-beta3 >=0),
allcond= cond1 & cond2 & cond3,
bound2=pmin(1,1-( k*(k+1)*(1-beta1) + (2*k+1)*(beta2-beta1) -(beta3-beta2) )/(k^2+k) ),
bound=ifelse(allcond,bound2,bound1)  )%>%
#          bound=pmin(1,S1-S2+S3,S1-(2*m-3)*S2/choose(m,2)+(m-2)*S3/choose(m,3) )) %>%
select(alpha,bound)
bounds <- add_row(bounds,alpha=c(0,1),bound=c(0,1))
return(approxfun(bounds$alpha,bounds$bound,method = "linear"))
}
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/bound3test.R')
m
install.packages("nloptr")
install.packages("rARPACK")
library(corihw)
library(corihw)
?corihw
library("corihw")
?corihw
library("DESeq2")
library("dplyr")
data("airway", package = "airway")
dds <- DESeqDataSet(se = airway, design = ~ cell + dex) %>% DESeq
deRes <- as.data.frame(results(dds))
desRes %>% as_tibble()
deRes %>% as_tibble()
airway
correlation
?Matrix
?bdiag
?rmvnorm
library(mvtnorm)
?rmvnorm
#' toy_example: Creates a toy example data of multiple correlated tests
#'
#' Create \emph{m} two-sample t-tests with correlations. Let \emph{mu} be the mean under
#' the alternative and 0 the mean under the null. The proportion of alternatives is \emph{prob}.
#' The first sample of \emph{n}  \emph{m}-dimendional observations is drawn from a multivariate random vector with mean 0 for null
#'  and mean \emph{mu} for alternatives. The second sample of \emph{n} \emph{m}-dimendional observations is drawn from with mean zero.
#'  The correlation matrix \emph{R} is block diagonal with a given \emph{block size} and with off-diagonal entries of \emph{correlation}.
#'
#'
#' @param m Number of tests
#' @param n Number of observations in each of the two samples
#' @param mu The mean under the alternative
#' @param prob The probability of alternatives
#' @param block_size The size of the blocks in the block-diagonal correlation matrix R.
#' @param rho The off-diagonal entries of th block matrices
#'
#'
#'
#' @return A data frame with P-values (P) and the pooled variance as the informative covariate (X)
#'
#' @import
#' @import IHW
#' @importFrom stats approxfun pnorm qnorm runif uniroot
#' @export
toy_example <- function(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8){
mat <- Matrix::Matrix((1-rho)*diag(block_size)+matrix(rho,block_size,block_size))
lmat <- list()
Z <- NULL
for(i in 1:ceiling(m/block_size)){
lmat <-c(lmat,mat)
Z <- cbind(Z,mvtnorm::rmvnorm(n = n, sigma=as.matrix(mat)))
}
Sigma <- Matrix::bdiag(lmat)
Sigma <- Sigma[1:m,1:m]
Z0 <- Z[,1:m]
H <- rbinom(n = m,size = 1,prob = prob)
H <- matrix(H,nrow=2*n,ncol=m,byrow = T)
H[(n+1):2*n,] <- 0
Z <- data.frame(Z0+H*mu)
X <- apply(Z,2,var)
P <- matrixTests::col_t_equalvar(Z[1:n1,],Z[(n1+1):n,])$pvalue
return(data.frame(P,X))
}
#' toy_example: Creates a toy example data of multiple correlated tests
#'
#' Create \emph{m} two-sample t-tests with correlations. Let \emph{mu} be the mean under
#' the alternative and 0 the mean under the null. The proportion of alternatives is \emph{prob}.
#' The first sample of \emph{n}  \emph{m}-dimendional observations is drawn from a multivariate random vector with mean 0 for null
#'  and mean \emph{mu} for alternatives. The second sample of \emph{n} \emph{m}-dimendional observations is drawn from with mean zero.
#'  The correlation matrix \emph{R} is block diagonal with a given \emph{block size} and with off-diagonal entries of \emph{correlation}.
#'
#'
#' @param m Number of tests
#' @param n Number of observations in each of the two samples
#' @param mu The mean under the alternative
#' @param prob The probability of alternatives
#' @param block_size The size of the blocks in the block-diagonal correlation matrix R.
#' @param rho The off-diagonal entries of th block matrices
#'
#'
#'
#' @return A data frame with P-values (P) and the pooled variance as the informative covariate (X)
#'
#' @importFrom Matrix Matrix bdiag
#' @importFrom mvtnorm rmvnorm
#' @importFrom matrixTests col_t_equalvar
toy_example <- function(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8){
mat <- Matrix::Matrix((1-rho)*diag(block_size)+matrix(rho,block_size,block_size))
lmat <- list()
Z <- NULL
for(i in 1:ceiling(m/block_size)){
lmat <-c(lmat,mat)
Z <- cbind(Z,mvtnorm::rmvnorm(n = n, sigma=as.matrix(mat)))
}
Sigma <- Matrix::bdiag(lmat)
Sigma <- Sigma[1:m,1:m]
Z0 <- Z[,1:m]
H <- rbinom(n = m,size = 1,prob = prob)
H <- matrix(H,nrow=2*n,ncol=m,byrow = T)
H[(n+1):2*n,] <- 0
Z <- data.frame(Z0+H*mu)
X <- apply(Z,2,var)
P <- matrixTests::col_t_equalvar(Z[1:n1,],Z[(n1+1):n,])$pvalue
return(data.frame(P,X))
}
res <- toy_example()
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/toy_example.R')
res <- toy_example()
m=10000;n=15;mu=1;prob=0.05; block_size=100;rho=0.8
mat <- Matrix::Matrix((1-rho)*diag(block_size)+matrix(rho,block_size,block_size))
lmat <- list()
Z <- NULL
for(i in 1:ceiling(m/block_size)){
lmat <-c(lmat,mat)
Z <- cbind(Z,mvtnorm::rmvnorm(n = 2*n, sigma=as.matrix(mat)))
}
Sigma <- Matrix::bdiag(lmat)
Sigma <- Sigma[1:m,1:m]
Z0 <- Z[,1:m]
dim(Z0)
H <- rbinom(n = m,size = 1,prob = prob)
H <- matrix(H,nrow=2*n,ncol=m,byrow = T)
H[(n+1):2*n,] <- 0
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/toy_example.R')
res <- toy_example()
res
head(res)
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/toy_example.R')
res <- toy_example()
?data.frame
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/toy_example.R')
res <- toy_example()
head(res)
library(corihw)
?toy_example
?corihw
library(corihw)
library(devtools)
document()
document()
?toy_example
document()
library(corihw)
dat <- toy_example(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
dat
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/toy_example.R')
dat <- toy_example(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
dat$Z
dat$R
?ihw
?corihw
library(corihw)
dat <- toy_example(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=Sigma)
?tibble
document()
warnings()
document()
document()
library(devtools)
document()
document()
document()
document()
document()
?triu
?sparseMatrix
document()
library(corihw)
?corihw
library(corihw)
dat <- toy_example(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
library(corihw)
dat <- toy_example(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
library(corihw)
?omit_na
??omit_na
library(tidyr)
??omit_na
?omit_na
?na_omit
?drop_na
document()
library(corihw)
library(corihw)
dat <- toy_example(m=10000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=Sigma)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$Sigma)
dat$X
typeof(dat$X)
dat$R
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R)
library(corihw)
library(corihw)
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R )
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R )
library(tidyverse)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R )
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R )
i
nfolds
dat$folds
Sigma
dim(Sigma)
library(corihw)
document()
library(corihw)
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.8)
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$R )
sol_corihw <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$Sigma )
sol
sol_corihw
rejections_ihw <- sum(sol$rjs_IHW)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$Sigma )
rejections_ihw <- sum(sol$rjs_IHW)
rejections_corihw <- sum(sol$rjs_Cor)
rejections_corihw_linear <- sum(sol$rjs_CorLinear)
rejections_corihw_meffective <- sum(sol$rjs_meffective)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$Sigma,quiet = T,bound3_testing = F )
rejections_ihw <- sum(sol$rjs_IHW)
rejections_corihw <- sum(sol$rjs_Cor)
rejections_corihw_linear <- sum(sol$rjs_CorLinear)
rejections_corihw_meffective <- sum(sol$rjs_meffective)
rm(list=ls())
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.9)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=1,Sigma=dat$Sigma,quiet = T)
rejections <- data.frame(ihw  = sum(sol$rjs_IHW),
corihw = sum(sol$rjs_Cor),
cor_linear = sum(sol$rjs_CorLinear),
cor_meffective = sum(sol$rjs_meffective))
rejections
library(corihw)
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.9)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
rejections <- data.frame(ihw  = sum(sol$rjs_IHW),
corihw = sum(sol$rjs_Cor),
cor_linear = sum(sol$rjs_CorLinear),
cor_meffective = sum(sol$rjs_meffective))
rejections
document()
library(corihw)
rm(list=ls())
library(corihw)
rm(list=ls())
library(corihw)
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.9)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
library(corihw)
rm(list=ls())
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.9)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
rm(list=ls())
library(corihw)
rm(list=ls())
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.9)
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
sol
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = T)
methods
bound3_linear_testing
bound3_testing
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = F)
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
debugSource('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
rm(list=ls())
source('C:/Users/User/Dropbox/Li Hsu/Shared/CorrelatedIHW/Code/corihw/corihw/R/corihw.R')
sol <- corihw (pvalues = dat$P,covariates = dat$X,alpha = 0.1,lambda=5,Sigma=dat$Sigma,quiet = F)
dat <- toy_example(m=20000,n=15,mu=1,prob=0.05, block_size=100,rho=0.9)
